/*
1010. 总持续时间可被 60 整除的歌曲
在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。
返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。
形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。
示例 1：
输入：[30,20,150,100,40]
输出：3
解释：这三对的总持续时间可被 60 整数：
(time[0] = 30, time[2] = 150): 总持续时间 180
(time[1] = 20, time[3] = 100): 总持续时间 120
(time[1] = 20, time[4] = 40): 总持续时间 60
示例 2：
输入：[60,60,60]
输出：3
解释：所有三对的总持续时间都是 120，可以被 60 整数。
提示：
1 <= time.length <= 60000
1 <= time[i] <= 500
来源：LeetCode
链接：https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/
*/
class Solution {
public:
    int numPairsDivisibleBy60(vector<int>& time) {
        int res = 0;
        map<int, int> mp;
        for(auto e : time)
        {
            res += mp[(60 - e % 60) % 60];
            ++mp[e % 60];
        }
        
        return res;
    }
};
//我们直接把取余的结果当作hash的下标，其对应的元素表示出现这个下标（也就是余数）的次数
//而且，针对每个数，只统计在此之前出现过的，其实这和双指针的思想有些类似,只进不退
//这样做的结果是，当我们t%60之后，我要找在此之前对应的60-t%60就好找了，直接通过下标访问
//假如下标所对应的元素不为零，说明在此之前出现过和我这个数匹配的数，这个元素是几，res就加几
//循环一遍，即可完成，比我之前那两个for不知道快到哪儿去了